{"changed":true,"filter":false,"title":"mision1_1.py","tooltip":"/mision1/mision1_1.py","value":"#!/usr/bin/env python\n\nimport nxt.bluesock\nimport nxt.locator\nfrom nxt.motor import *\nimport math\nimport time\n\ndef connect(mode, mac):\n    if(mode==\"Usb\"):\n        return nxt.locator.find_one_brick()\n    else:\n        return nxt.bluesock.BlueSock(mac).connect()\n\n\nclass Robot:\n\n    def __init__(self, brick, tam_encoder=360, wheel_diameter=5.6):\n        \n        self.brick_= brick\n        self.separationBetweenWheels_= 13\n        self.syncMotor_ = SynchronizedMotors(Motor(self.brick_, PORT_B), Motor(self.brick_, PORT_C), 0)\n        self.cuenta_= ((wheel_diameter*math.pi)/tam_encoder)\n\n        # 1. Calculamos las cuentas que tendra que pasar para girar hacia un stolado.\n        # Si suponemos que un giro sobre si mismo es de de radio separationBewteenWheels, un giro solo ocupara una\n        # cuarta parte del perimetro de la circunferencia.\n        turn_perimeter = (math.pi * 2.0 * self.separationBetweenWheels_) / 4.0\n        self.cuentasGiro_ = turn_perimeter / self.cuenta_\n\n    def moveTurnTime(self,t, power):\n\n        current_time = time.time()\n        self.syncMotor_.run(80*power)\n        while (time.time() - current_time < t):\n            pass;      \n        self.syncMotor_.brake()\n\n    def mision(self):\n\n\n        # 1.Mover robot hacia delante 3 segundos\n        self.moveTurnTime(3.0,1)\n        time.sleep(1)\n         \n        # 2.Girar a la derecha\n        self.syncMotor_.leader.weak_turn(80, self.cuentasGiro_)\n        time.sleep(1)\n\n        # 3.Mover robot hacia delante 2 segundos\n        self.moveTurnTime(2.0,1)\n        time.sleep(1)\n\n        # 4. Girar a la izquierda\n        self.syncMotor_.follower.weak_turn(80, self.cuentasGiro_)\n        time.sleep(1)\n\n        # 5. Moverse hacia delante 3 segundos\n        self.moveTurnTime(3.0,1)\n        time.sleep(1)\n\n        self.syncMotor_.follower.weak_turn(80, self.cuentasGiro_)\n        time.sleep(1)\n\n        self.moveTurnTime(3.0,1)\n        time.sleep(1)\n\n        # 6. Dessincrnizacion motores\n        self.syncMotor_.idle()\n\n        # 7. Emitir sonido de finalizacion\n        self.brick_.play_tone_and_wait(659, 500)\n\n    def optional(self):\n\n        self.syncMotor_ = SynchronizedMotors(Motor(self.brick_, PORT_B), Motor(self.brick_, PORT_C), 0)\n\n        self.moveTurnTime(1.0, -1)\n        time.sleep(1)\n\n        self.syncMotor_.follower.weak_turn(-80, self.cuentasGiro_)\n        time.sleep(1)\n\n        self.moveTurnTime(3.0,-1)\n        time.sleep(1)\n\n        self.syncMotor_.follower.weak_turn(-80, self.cuentasGiro_)\n        time.sleep(1)\n\n        self.moveTurnTime(2.0,-1)\n        time.sleep(1)\n\n        self.syncMotor_.leader.weak_turn(-80, self.cuentasGiro_)\n        time.sleep(1)\n\n        self.moveTurnTime(3.0,-1)\n        time.sleep(1)\n\n\n\n","undoManager":{"stack":[],"mark":-1,"position":-1},"ace":{"folds":[],"scrolltop":111,"scrollleft":0,"selection":{"start":{"row":13,"column":0},"end":{"row":13,"column":0},"isBackwards":false},"options":{"guessTabSize":true,"useWrapMode":false,"wrapToView":true},"firstLineState":{"row":10,"state":"start","mode":"ace/mode/python"}},"timestamp":1430662128000}